import { _ as _class_private_field_loose_base } from "@swc/helpers/_/_class_private_field_loose_base";
import { _ as _class_private_field_loose_key } from "@swc/helpers/_/_class_private_field_loose_key";
var _updatedModules = /*#__PURE__*/ _class_private_field_loose_key("_updatedModules"), _startMsSinceEpoch = /*#__PURE__*/ _class_private_field_loose_key("_startMsSinceEpoch"), _lastUpdateMsSinceEpoch = /*#__PURE__*/ _class_private_field_loose_key("_lastUpdateMsSinceEpoch");
export class TurbopackHmr {
    onBuilding() {
        _class_private_field_loose_base(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = undefined;
        _class_private_field_loose_base(this, _startMsSinceEpoch)[_startMsSinceEpoch] = Date.now();
    }
    onTurbopackMessage(msg) {
        _class_private_field_loose_base(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = Date.now();
        const updatedModules = extractModulesFromTurbopackMessage(msg.data);
        for (const module of updatedModules){
            _class_private_field_loose_base(this, _updatedModules)[_updatedModules].add(module);
        }
    }
    onBuilt() {
        // it's possible for `this.#startMsSinceEpoch` to not be set if this was the initial
        // computation, just return null in this case.
        if (_class_private_field_loose_base(this, _startMsSinceEpoch)[_startMsSinceEpoch] == null) {
            return null;
        }
        var _class_private_field_loose_base__lastUpdateMsSinceEpoch;
        const result = {
            updatedModules: _class_private_field_loose_base(this, _updatedModules)[_updatedModules],
            startMsSinceEpoch: _class_private_field_loose_base(this, _startMsSinceEpoch)[_startMsSinceEpoch],
            // Turbopack has a debounce which causes every BUILT message to appear
            // 30ms late. We don't want to include this latency in our reporting, so
            // prefer to use the last TURBOPACK_MESSAGE time.
            endMsSinceEpoch: (_class_private_field_loose_base__lastUpdateMsSinceEpoch = _class_private_field_loose_base(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch]) != null ? _class_private_field_loose_base__lastUpdateMsSinceEpoch : Date.now()
        };
        _class_private_field_loose_base(this, _updatedModules)[_updatedModules] = new Set();
        return result;
    }
    constructor(){
        Object.defineProperty(this, _updatedModules, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _startMsSinceEpoch, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _lastUpdateMsSinceEpoch, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base(this, _updatedModules)[_updatedModules] = new Set();
    }
}
function extractModulesFromTurbopackMessage(data) {
    const updatedModules = new Set();
    const updates = Array.isArray(data) ? data : [
        data
    ];
    for (const update of updates){
        // TODO this won't capture changes to CSS since they don't result in a "merged" update
        if (update.type !== 'partial' || update.instruction.type !== 'ChunkListUpdate' || update.instruction.merged === undefined) {
            continue;
        }
        for (const mergedUpdate of update.instruction.merged){
            for (const name of Object.keys(mergedUpdate.entries)){
                const res = /(.*)\s+\[.*/.exec(name);
                if (res === null) {
                    console.error('[Turbopack HMR] Expected module to match pattern: ' + name);
                    continue;
                }
                updatedModules.add(res[1]);
            }
        }
    }
    return updatedModules;
}

//# sourceMappingURL=turbopack-hot-reloader-common.js.map